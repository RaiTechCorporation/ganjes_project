import pkg from 'hardhat';
const { ethers, artifacts } = pkg;
import dotenv from "dotenv";

dotenv.config();

async function fixedVote() {
    try {
        console.log("üó≥Ô∏è  Fixed Voting Script");
        console.log("========================\n");
        
        const [signer] = await ethers.getSigners();
        console.log("üìù Using account:", signer.address);
        
        const daoAddress = process.env.DAO_ADDRESS;
        const tokenAddress = process.env.TOKEN_ADDRESS;
        
        if (!daoAddress || !tokenAddress) {
            throw new Error("‚ùå DAO_ADDRESS and TOKEN_ADDRESS must be set in .env file");
        }
        
        console.log("üèõÔ∏è  DAO Contract:", daoAddress);
        console.log("üí∞ Token Contract:", tokenAddress);
        
        const daoArtifact = await artifacts.readArtifact("GanjesDAOOptimized");
        const tokenArtifact = await artifacts.readArtifact("SimpleToken");
        
        const dao = new ethers.Contract(daoAddress, daoArtifact.abi, signer);
        const token = new ethers.Contract(tokenAddress, tokenArtifact.abi, signer);
        
        // Get basic info
        const userBalance = await token.balanceOf(signer.address);
        const minInvestment = await dao.minInvestmentAmount();
        
        console.log(`üí≥ Your Token Balance: ${ethers.formatEther(userBalance)} tokens`);
        console.log(`üíµ Minimum Investment: ${ethers.formatEther(minInvestment)} tokens`);
        
        if (userBalance < minInvestment) {
            throw new Error(`‚ùå Insufficient tokens. Need at least ${ethers.formatEther(minInvestment)} tokens`);
        }
        
        // Check proposals
        const totalProposals = await dao.getTotalProposals();
        console.log(`üìä Total Proposals: ${totalProposals}`);
        
        if (totalProposals === 0n) {
            throw new Error("‚ùå No proposals exist to vote on");
        }
        
        // Get proposal 1 details using the correct struct order
        console.log("\nüìã Getting Proposal #1 details...");
        const proposal = await dao.proposals(1);
        
        console.log(`üìõ Project: ${proposal.projectName}`);
        console.log(`üë§ Proposer: ${proposal.proposer}`);
        console.log(`üí∞ Goal: ${ethers.formatEther(proposal.fundingGoal)} tokens`);
        console.log(`üìà Invested: ${ethers.formatEther(proposal.totalInvested)} tokens`);
        console.log(`‚è∞ End Time: ${new Date(Number(proposal.endTime) * 1000)}`);
        console.log(`üèÅ Executed: ${proposal.executed}`);
        
        // Check voting eligibility
        const currentTime = Math.floor(Date.now() / 1000);
        
        if (proposal.executed) {
            throw new Error("‚ùå Proposal already executed");
        }
        
        if (Number(proposal.endTime) <= currentTime) {
            throw new Error("‚ùå Voting period ended");
        }
        
        if (proposal.proposer.toLowerCase() === signer.address.toLowerCase()) {
            throw new Error("‚ùå Cannot vote on own proposal");
        }
        
        // Check if already voted
        try {
            const userInvestment = await dao.getUserInvestment(1, signer.address);
            if (userInvestment.hasVoted) {
                throw new Error(`‚ùå Already voted with ${ethers.formatEther(userInvestment.investment)} tokens`);
            }
        } catch (error) {
            if (error.message.includes("Already voted")) {
                throw error;
            }
            console.log("‚úÖ User has not voted yet");
        }
        
        // Vote parameters
        const proposalId = 1;
        const support = true; // Vote FOR
        const investmentAmount = ethers.parseEther("10");
        
        console.log("\nüìä Vote Summary:");
        console.log(`   üÜî Proposal ID: #${proposalId}`);
        console.log(`   üó≥Ô∏è  Vote: ${support ? 'FOR' : 'AGAINST'}`);
        console.log(`   üí∞ Investment: ${ethers.formatEther(investmentAmount)} tokens`);
        
        // Check and approve tokens
        const currentAllowance = await token.allowance(signer.address, daoAddress);
        console.log(`üìù Current Allowance: ${ethers.formatEther(currentAllowance)} tokens`);
        
        if (currentAllowance < investmentAmount) {
            console.log("üîê Approving tokens...");
            const approveTx = await token.approve(daoAddress, investmentAmount);
            const approveReceipt = await approveTx.wait();
            console.log("‚úÖ Tokens approved:", approveReceipt.hash);
        }
        
        // Submit vote with comprehensive error handling
        console.log("\nüó≥Ô∏è  Submitting vote...");
        
        try {
            // First try a static call to catch revert reasons
            console.log("üîç Performing static call check...");
            await dao.vote.staticCall(proposalId, support, investmentAmount);
            console.log("‚úÖ Static call successful");
            
            // Estimate gas
            const gasEstimate = await dao.vote.estimateGas(proposalId, support, investmentAmount);
            console.log(`‚õΩ Gas estimate: ${gasEstimate}`);
            
            // Submit actual transaction
            const voteTx = await dao.vote(proposalId, support, investmentAmount, {
                gasLimit: gasEstimate + 100000n // Add buffer
            });
            
            console.log("üìù Transaction submitted:", voteTx.hash);
            console.log("‚è≥ Waiting for confirmation...");
            
            const receipt = await voteTx.wait();
            
            if (receipt.status === 0) {
                throw new Error("‚ùå Transaction failed (status: 0)");
            }
            
            console.log("‚úÖ Vote confirmed!");
            console.log(`üìÖ Block: ${receipt.blockNumber}`);
            console.log(`üí® Gas used: ${receipt.gasUsed}`);
            
            // Parse vote event
            const voteEvents = receipt.logs.filter(log => {
                try {
                    const parsed = dao.interface.parseLog(log);
                    return parsed.name === "Voted";
                } catch {
                    return false;
                }
            });
            
            if (voteEvents.length > 0) {
                const voteEvent = dao.interface.parseLog(voteEvents[0]);
                console.log("\nüéâ Vote Event Details:");
                console.log(`   üÜî Proposal: #${voteEvent.args.proposalId}`);
                console.log(`   üë§ Voter: ${voteEvent.args.voter}`);
                console.log(`   üó≥Ô∏è  Support: ${voteEvent.args.support ? 'FOR' : 'AGAINST'}`);
                console.log(`   üí∞ Investment: ${ethers.formatEther(voteEvent.args.investmentAmount)} tokens`);
                console.log(`   üìä Weight: ${ethers.formatEther(voteEvent.args.weight)} tokens`);
            }
            
            // Get updated proposal stats
            const updatedProposal = await dao.proposals(proposalId);
            console.log("\nüìà Updated Proposal Stats:");
            console.log(`   üëç Votes FOR: ${ethers.formatEther(updatedProposal.totalVotesFor)} (${updatedProposal.votersFor} voters)`);
            console.log(`   üëé Votes AGAINST: ${ethers.formatEther(updatedProposal.totalVotesAgainst)} (${updatedProposal.votersAgainst} voters)`);
            console.log(`   üí∏ Total Invested: ${ethers.formatEther(updatedProposal.totalInvested)} tokens`);
            
            console.log("\nüéâ VOTE SUCCESSFUL!");
            return {
                success: true,
                transactionHash: receipt.hash,
                blockNumber: receipt.blockNumber,
                gasUsed: receipt.gasUsed.toString()
            };
            
        } catch (voteError) {
            console.error("\nüí• VOTE TRANSACTION FAILED:");
            console.error("Error code:", voteError.code);
            console.error("Error message:", voteError.message);
            
            // Handle specific error types
            if (voteError.code === 'CALL_EXCEPTION') {
                console.error("\nüîç Transaction reverted. Possible reasons:");
                console.error("  - Insufficient token balance");
                console.error("  - Insufficient token allowance");
                console.error("  - Voting period has ended");
                console.error("  - Already voted on this proposal");
                console.error("  - Invalid proposal ID");
                console.error("  - Investment amount too low/high");
                
                // Check transaction receipt for more details
                if (voteError.receipt) {
                    console.error("üìÑ Transaction Receipt:");
                    console.error(`   Status: ${voteError.receipt.status}`);
                    console.error(`   Hash: ${voteError.receipt.hash}`);
                    console.error(`   Gas Used: ${voteError.receipt.gasUsed}`);
                    console.error(`   From: ${voteError.receipt.from}`);
                    console.error(`   To: ${voteError.receipt.to}`);
                    
                    // Try to get revert reason from receipt
                    if (voteError.receipt.logs && voteError.receipt.logs.length === 0) {
                        console.error("   No events emitted - transaction reverted");
                    }
                }
                
                // Try to decode error data if available
                if (voteError.data && typeof voteError.data === 'string') {
                    console.error(`   Error Data: ${voteError.data}`);
                    
                    // Common error signatures
                    const errorSignatures = {
                        "0x08c379a0": "Error(string)",
                        "0x4e487b71": "Panic(uint256)",
                        "0xe0cff6bf": "InsufficientBalance(uint256,uint256)",
                        "0x13be252b": "InsufficientAllowance(uint256,uint256)"
                    };
                    
                    const errorSig = voteError.data.slice(0, 10);
                    if (errorSignatures[errorSig]) {
                        console.error(`   Known Error Type: ${errorSignatures[errorSig]}`);
                    }
                }
            }
            
            // Network-specific errors
            if (voteError.code === 'NETWORK_ERROR') {
                console.error("\nüåê Network Error - Check your internet connection and RPC endpoint");
            }
            
            if (voteError.code === 'INSUFFICIENT_FUNDS') {
                console.error("\nüí∞ Insufficient funds for gas fees");
            }
            
            throw voteError;
        }
        
    } catch (error) {
        console.error("\n‚ùå SCRIPT FAILED:");
        console.error("Error:", error.message);
        
        if (error.stack) {
            console.error("Stack trace:", error.stack);
        }
        
        throw error;
    }
}

// Run the vote
fixedVote()
    .then((result) => {
        if (result?.success) {
            console.log(`\nüéâ Successfully voted! Transaction: ${result.transactionHash}`);
        }
        process.exit(0);
    })
    .catch((error) => {
        console.error("\nüí• Vote failed!");
        process.exit(1);
    });

export { fixedVote };